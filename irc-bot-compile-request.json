{
    "cppCode": "#include <iostream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <sstream>\n#include <fstream>\n#include <cstring>\n#include <cstdlib>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <regex>\n#include <map>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n\nclass IRCBot {\nprivate:\n    std::string server;\n    int port;\n    std::vector<std::string> channels;\n    std::string nick;\n    std::string username;\n    std::string realname;\n    std::string password;\n    \n    int socket_fd;\n    bool connected;\n    bool channels_joined;\n    std::queue<std::string> message_queue;\n    int reconnect_attempts;\n    int max_reconnect_attempts;\n    std::chrono::steady_clock::time_point last_message_time;\n    int rate_limit_delay;\n    \n    std::mutex message_mutex;\n    std::condition_variable message_cv;\n    std::thread message_thread;\n    bool running;\n\npublic:\n    IRCBot(const std::string& server = \"irc.rizon.net\", \n           int port = 6667,\n           const std::vector<std::string>& channels = {\"#rawr\"},\n           const std::string& nick = \"RawrZBot\",\n           const std::string& username = \"bibbles11\",\n           const std::string& realname = \"RawrZ Security Platform Monitor\",\n           const std::string& password = \"bibbles11\")\n        : server(server), port(port), channels(channels), nick(nick), \n          username(username), realname(realname), password(password),\n          socket_fd(-1), connected(false), channels_joined(false),\n          reconnect_attempts(0), max_reconnect_attempts(5),\n          rate_limit_delay(500), running(true) {\n        \n        last_message_time = std::chrono::steady_clock::now();\n        message_thread = std::thread(&IRCBot::messageProcessor, this);\n        connect();\n    }\n    \n    ~IRCBot() {\n        running = false;\n        message_cv.notify_all();\n        if (message_thread.joinable()) {\n            message_thread.join();\n        }\n        disconnect();\n    }\n\nprivate:\n    void connect() {\n        struct sockaddr_in server_addr;\n        struct hostent *host_info;\n        \n        // Create socket\n        socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n        if (socket_fd < 0) {\n            std::cerr << \"[BOT] Failed to create socket\" << std::endl;\n            reconnect();\n            return;\n        }\n        \n        // Get server info\n        host_info = gethostbyname(server.c_str());\n        if (host_info == nullptr) {\n            std::cerr << \"[BOT] Failed to resolve host: \" << server << std::endl;\n            close(socket_fd);\n            reconnect();\n            return;\n        }\n        \n        // Setup server address\n        memset(&server_addr, 0, sizeof(server_addr));\n        server_addr.sin_family = AF_INET;\n        server_addr.sin_port = htons(port);\n        memcpy(&server_addr.sin_addr, host_info->h_addr_list[0], host_info->h_length);\n        \n        // Connect to server\n        if (::connect(socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n            std::cerr << \"[BOT] Failed to connect to \" << server << \":\" << port << std::endl;\n            close(socket_fd);\n            reconnect();\n            return;\n        }\n        \n        std::cout << \"[BOT] Connected to IRC server: \" << server << \":\" << port << std::endl;\n        connected = true;\n        channels_joined = false;\n        reconnect_attempts = 0;\n        \n        // Send IRC registration\n        sendRaw(\"NICK \" + nick);\n        sendRaw(\"USER \" + username + \" 0 * :\" + realname);\n        \n        // Process queued messages\n        std::lock_guard<std::mutex> lock(message_mutex);\n        while (!message_queue.empty()) {\n            std::string message = message_queue.front();\n            message_queue.pop();\n            sendToIRC(message);\n        }\n        \n        // Start receiving data\n        std::thread(&IRCBot::receiveData, this).detach();\n    }\n    \n    void receiveData() {\n        char buffer[4096];\n        std::string line;\n        \n        while (connected && running) {\n            int bytes_received = recv(socket_fd, buffer, sizeof(buffer) - 1, 0);\n            if (bytes_received <= 0) {\n                if (bytes_received == 0) {\n                    std::cout << \"[BOT] IRC connection closed by server\" << std::endl;\n                } else {\n                    std::cerr << \"[BOT] IRC connection error\" << std::endl;\n                }\n                connected = false;\n                reconnect();\n                break;\n            }\n            \n            buffer[bytes_received] = '\\0';\n            line += buffer;\n            \n            // Process complete lines\n            size_t pos = 0;\n            while ((pos = line.find(\"\\r\\n\")) != std::string::npos) {\n                std::string complete_line = line.substr(0, pos);\n                line.erase(0, pos + 2);\n                \n                if (!complete_line.empty()) {\n                    handleIRCLine(complete_line);\n                }\n            }\n        }\n    }\n    \n    void handleIRCLine(const std::string& line) {\n        // Handle PING\n        if (line.substr(0, 4) == \"PING\") {\n            std::string server_name = line.substr(5);\n            sendRaw(\"PONG \" + server_name);\n            return;\n        }\n        \n        // Handle authentication\n        if (line.find(\"NickServ\") != std::string::npos && line.find(\"IDENTIFY\") != std::string::npos) {\n            sendRaw(\"PRIVMSG NickServ :IDENTIFY \" + password);\n            std::cout << \"[BOT] IRC: Identifying with NickServ\" << std::endl;\n            return;\n        }\n        \n        // Try to identify after MOTD\n        if (line.find(\"376\") != std::string::npos || line.find(\"End of /MOTD command\") != std::string::npos) {\n            std::cout << \"[BOT] IRC: MOTD received, attempting NickServ identification\" << std::endl;\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n            sendRaw(\"PRIVMSG NickServ :IDENTIFY \" + password);\n            std::cout << \"[BOT] IRC: Sending NickServ identify command\" << std::endl;\n        }\n        \n        // Handle successful authentication\n        if (line.find(\"You are now identified\") != std::string::npos || \n            line.find(\"Password accepted\") != std::string::npos ||\n            line.find(\"You are successfully identified\") != std::string::npos) {\n            std::cout << \"[BOT] IRC: Successfully authenticated\" << std::endl;\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n            for (const auto& channel : channels) {\n                sendRaw(\"JOIN \" + channel);\n                std::cout << \"[BOT] IRC: Joining channel \" << channel << std::endl;\n            }\n            return;\n        }\n        \n        // Handle MOTD end (fallback for channels that don't require auth)\n        if (line.find(\"End of /MOTD command\") != std::string::npos || line.find(\"376\") != std::string::npos) {\n            if (!channels_joined) {\n                std::cout << \"[BOT] IRC: MOTD received, joining channels\" << std::endl;\n                channels_joined = true;\n                std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n                for (const auto& channel : channels) {\n                    sendRaw(\"JOIN \" + channel);\n                    std::cout << \"[BOT] IRC: Joining channel \" << channel << std::endl;\n                }\n            }\n            return;\n        }\n        \n        // Handle channel messages\n        handleChannelMessage(line);\n    }\n    \n    void handleChannelMessage(const std::string& line) {\n        std::regex message_regex(R\"(:([^!]+)![^@]+@[^ ]+ PRIVMSG ([^ ]+) :(.+))\");\n        std::smatch match;\n        \n        if (std::regex_match(line, match, message_regex)) {\n            std::string nick_sender = match[1].str();\n            std::string channel = match[2].str();\n            std::string message = match[3].str();\n            \n            if (message.substr(0, 1) == \"!\") {\n                handleCommand(nick_sender, channel, message);\n            }\n        }\n    }\n    \n    void handleCommand(const std::string& nick, const std::string& channel, const std::string& message) {\n        std::istringstream iss(message);\n        std::vector<std::string> args;\n        std::string arg;\n        \n        while (iss >> arg) {\n            args.push_back(arg);\n        }\n        \n        if (args.empty()) return;\n        \n        std::string command = args[0];\n        std::transform(command.begin(), command.end(), command.begin(), ::tolower);\n        \n        if (command == \"!status\") {\n            sendSystemStatus(nick);\n        } else if (command == \"!help\") {\n            sendHelp(nick, args.size() > 1 ? args[1] : \"\");\n        } else if (command == \"!ping\") {\n            sendToIRC(nick + \": Pong! RawrZ Security Platform is online and ready.\");\n        } else if (command == \"!version\") {\n            sendToIRC(nick + \": RawrZ Security Platform v1.0.0 - Native C++ IRC Bot\");\n        } else if (command == \"!info\") {\n            sendToIRC(nick + \": RawrZ Security Platform - Advanced Security Tools\");\n            sendToIRC(nick + \": Features: Encryption, Stealth, Anti-Analysis, Reverse Engineering\");\n            sendToIRC(nick + \": Native C++ implementation for maximum performance\");\n        } else if (command == \"!commands\") {\n            sendToIRC(nick + \": Available commands: !status, !help, !ping, !version, !info, !commands\");\n        } else {\n            sendToIRC(nick + \": Unknown command. Use !help for available commands.\");\n        }\n    }\n    \n    void sendSystemStatus(const std::string& nick) {\n        sendToIRC(nick + \": [STATUS] RawrZ Security Platform - Native C++ IRC Bot\");\n        sendToIRC(nick + \": [STATUS] System Health: Online and Operational\");\n        sendToIRC(nick + \": [STATUS] Connection: Connected to \" + server + \":\" + std::to_string(port));\n        sendToIRC(nick + \": [STATUS] Channels: \" + std::to_string(channels.size()) + \" active\");\n        sendToIRC(nick + \": [STATUS] Uptime: Active and monitoring\");\n    }\n    \n    void sendHelp(const std::string& nick, const std::string& category) {\n        if (category.empty()) {\n            sendToIRC(nick + \": [BOT] RawrZ Security Platform - Native C++ IRC Bot\");\n            sendToIRC(nick + \": [CORE] !status, !help, !ping, !version, !info, !commands\");\n            sendToIRC(nick + \": [HELP] Use !help <category> for detailed information\");\n        } else {\n            sendToIRC(nick + \": [HELP] Category: \" + category);\n            sendToIRC(nick + \": [HELP] This is a native C++ implementation of the RawrZ IRC Bot\");\n            sendToIRC(nick + \": [HELP] For full features, use the web interface at http://localhost:3000\");\n        }\n    }\n    \n    void sendToIRC(const std::string& message) {\n        if (!connected || socket_fd < 0) {\n            std::lock_guard<std::mutex> lock(message_mutex);\n            message_queue.push(message);\n            return;\n        }\n        \n        // Rate limiting\n        auto now = std::chrono::steady_clock::now();\n        auto time_since_last = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_message_time).count();\n        \n        if (time_since_last < rate_limit_delay) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(rate_limit_delay - time_since_last));\n        }\n        \n        last_message_time = std::chrono::steady_clock::now();\n        \n        for (const auto& channel : channels) {\n            sendRaw(\"PRIVMSG \" + channel + \" :\" + message);\n        }\n    }\n    \n    void sendRaw(const std::string& command) {\n        if (connected && socket_fd >= 0) {\n            std::string full_command = command + \"\\r\\n\";\n            send(socket_fd, full_command.c_str(), full_command.length(), 0);\n        }\n    }\n    \n    void messageProcessor() {\n        while (running) {\n            std::unique_lock<std::mutex> lock(message_mutex);\n            message_cv.wait(lock, [this] { return !message_queue.empty() || !running; });\n            \n            while (!message_queue.empty() && connected) {\n                std::string message = message_queue.front();\n                message_queue.pop();\n                lock.unlock();\n                \n                sendToIRC(message);\n                \n                lock.lock();\n            }\n        }\n    }\n    \n    void reconnect() {\n        if (reconnect_attempts >= max_reconnect_attempts) {\n            std::cerr << \"[BOT] Max reconnection attempts reached, giving up\" << std::endl;\n            return;\n        }\n        \n        reconnect_attempts++;\n        int delay = std::min(1000 * (1 << reconnect_attempts), 30000);\n        \n        std::cout << \"[BOT] Reconnecting to IRC in \" << delay << \"ms (attempt \" \n                  << reconnect_attempts << \"/\" << max_reconnect_attempts << \")\" << std::endl;\n        \n        std::this_thread::sleep_for(std::chrono::milliseconds(delay));\n        connect();\n    }\n    \n    void disconnect() {\n        if (connected && socket_fd >= 0) {\n            sendToIRC(\"[BOT] RawrZ Monitor disconnecting...\");\n            sendRaw(\"QUIT :RawrZ Security Platform Monitor shutting down\");\n            close(socket_fd);\n            connected = false;\n        }\n    }\n};\n\nint main() {\n    std::cout << \"RawrZ Security Platform - Native C++ IRC Bot\" << std::endl;\n    std::cout << \"Connecting to irc.rizon.net #rawr...\" << std::endl;\n    \n    IRCBot bot(\"irc.rizon.net\", 6667, {\"#rawr\"}, \"RawrZBot\", \"bibbles11\", \n               \"RawrZ Security Platform Monitor\", \"bibbles11\");\n    \n    // Keep the bot running\n    while (true) {\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n    \n    return 0;\n}"
}
