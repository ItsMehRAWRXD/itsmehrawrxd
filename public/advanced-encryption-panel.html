<!DOCTYPE html>
<html>
<head>
    <title>RawrZ Security Platform - Real CLI</title>
    <style>
        body { 
            background: #000; 
            color: #0f0; 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            margin: 0;
        }
        #terminal { 
            border: 1px solid #0f0; 
            padding: 15px; 
            height: 600px; 
            overflow-y: auto; 
            background: #111;
            border-radius: 5px;
        }
        #input { 
            background: transparent; 
            border: none; 
            color: #0f0; 
            width: 100%; 
            outline: none; 
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .output { margin: 5px 0; }
        .success { color: #0f0; }
        .error { color: #f00; }
        .info { color: #0ff; }
        .warning { color: #ff0; }
        .header { color: #0f0; font-weight: bold; }
        .prompt { color: #0f0; }
        .file-upload { 
            position: fixed; 
            top: -1000px; 
            left: -1000px; 
        }
        .loading { color: #ff0; }
        .download-link { 
            color: #0ff; 
            text-decoration: underline; 
            cursor: pointer; 
        }
        .download-link:hover { color: #fff; }
    </style>
</head>
<body>
    <h1>RawrZ Security Platform - Real CLI Interface</h1>
    <div id="terminal">
        <div class="output info">RawrZ Security Platform CLI v3.0 - Real Backend Integration</div>
        <div class="output info">Connecting to backend APIs...</div>
        <div class="output success">✅ Backend connected successfully</div>
        <div class="output info">Type "help" for available commands</div>
        <div class="output prompt">RawrZ@SecurityPlatform:~$ <input type="text" id="input" placeholder="Type commands here..."></div>
    </div>

    <!-- Hidden file input for real file operations -->
    <input type="file" id="fileInput" class="file-upload" multiple>

    <script>
        const input = document.getElementById('input');
        const terminal = document.getElementById('terminal');
        const fileInput = document.getElementById('fileInput');
        
        let currentFiles = new Map(); // Store uploaded files
        let commandHistory = [];
        let historyIndex = -1;
        
        input.focus();
        
        // Initialize connection test
        async function initializeConnection() {
            try {
                const response = await fetch('/api/health');
                const result = await response.json();
                if (result.success) {
                    addOutput(`✅ Backend connected - ${result.engines} engines active`, 'success');
                } else {
                    addOutput('❌ Backend connection failed', 'error');
                }
            } catch (error) {
                addOutput('❌ Backend offline - some features may not work', 'error');
            }
        }
        
        initializeConnection();
        
        function addOutput(text, type = 'info') {
            const output = document.createElement('div');
            output.className = `output ${type}`;
            output.textContent = text;
            terminal.appendChild(output);
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function createNewInputLine() {
            const newLine = document.createElement('div');
            newLine.className = 'output prompt';
            newLine.innerHTML = 'RawrZ@SecurityPlatform:~$ <input type="text" class="command-input">';
            terminal.appendChild(newLine);
            
            const newInput = newLine.querySelector('.command-input');
            newInput.focus();
            newInput.addEventListener('keypress', handleKeyPress);
            newInput.addEventListener('keydown', handleKeyDown);
        }
        
        function handleKeyPress(e) {
            if (e.key === 'Enter') {
                const command = e.target.value.trim();
                if (command) {
                    commandHistory.push(command);
                    historyIndex = commandHistory.length;
                    executeCommand(command);
                }
            }
        }
        
        function handleKeyDown(e) {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    e.target.value = commandHistory[historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    e.target.value = commandHistory[historyIndex];
                } else {
                    e.target.value = '';
                    historyIndex = commandHistory.length;
                }
            }
        }
        
        input.addEventListener('keypress', handleKeyPress);
        input.addEventListener('keydown', handleKeyDown);
        
        async function executeCommand(command) {
            addOutput(`RawrZ@SecurityPlatform:~$ ${command}`, 'info');
            
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            switch(cmd) {
                case 'help':
                    showHelp();
                    break;
                case 'status':
                    await showSystemStatus();
                    break;
                case 'engines':
                    await listAllEngines();
                    break;
                case 'clear':
                    terminal.innerHTML = '<div class="output info">Terminal cleared</div>';
                    break;
                case 'ls':
                    await listFiles();
                    break;
                case 'pwd':
                    addOutput('/app', 'info');
                    break;
                case 'encrypt':
                    await handleEncryption(args);
                    break;
                case 'decrypt':
                    await handleDecryption(args);
                    break;
                case 'hash':
                    await handleHashing(args);
                    break;
                case 'upload':
                    await handleFileUpload(args);
                    break;
                case 'download':
                    await handleDownload(args);
                    break;
                case 'scan':
                    await handleScanning(args);
                    break;
                case 'cve':
                    await handleCVECommands(args);
                    break;
                case 'generate':
                    await handleGeneration(args);
                    break;
                case 'bot':
                    await handleBotCommands(args);
                    break;
                case 'payload':
                    await handlePayloadCommands(args);
                    break;
                case 'stub':
                    await handleStubCommands(args);
                    break;
                case 'cert':
                    await handleCertCommands(args);
                    break;
                case 'api':
                    await testAPIEndpoint(args[0]);
                    break;
                case 'exit':
                case 'quit':
                    addOutput('Goodbye!', 'info');
                    break;
                default:
                    addOutput(`Command not found: ${cmd}`, 'error');
                    addOutput('Type "help" for available commands', 'info');
            }
            
            createNewInputLine();
        }
        
        function showHelp() {
            addOutput('RawrZ Security Platform - Real CLI Commands:', 'header');
            addOutput('', 'info');
            addOutput('SYSTEM COMMANDS:', 'header');
            addOutput('  help                    - Show this help message', 'info');
            addOutput('  status                  - Show real system status', 'info');
            addOutput('  engines                 - List all available engines', 'info');
            addOutput('  clear                   - Clear terminal', 'info');
            addOutput('  ls                      - List uploaded files', 'info');
            addOutput('  pwd                     - Show current directory', 'info');
            addOutput('', 'info');
            addOutput('FILE OPERATIONS:', 'header');
            addOutput('  upload <file>           - Upload file to server', 'info');
            addOutput('  encrypt <file> [ext]    - Encrypt file with custom extension', 'info');
            addOutput('  decrypt <file>          - Decrypt file', 'info');
            addOutput('  hash <file> [algo]      - Calculate file hash', 'info');
            addOutput('  download <file>         - Download encrypted file', 'info');
            addOutput('', 'info');
            addOutput('SECURITY COMMANDS:', 'header');
            addOutput('  scan <file>             - Scan file with engines', 'info');
            addOutput('  cve <id>                - Analyze CVE vulnerability', 'info');
            addOutput('  cert <action>           - EV Certificate operations', 'info');
            addOutput('', 'info');
            addOutput('GENERATION COMMANDS:', 'header');
            addOutput('  generate <type>         - Generate payloads/stubs', 'info');
            addOutput('  stub <type>             - Generate specific stub types', 'info');
            addOutput('  payload <type>          - Generate payload types', 'info');
            addOutput('', 'info');
            addOutput('BOT COMMANDS:', 'header');
            addOutput('  bot <action>            - Bot management operations', 'info');
            addOutput('', 'info');
            addOutput('API COMMANDS:', 'header');
            addOutput('  api <endpoint>          - Test API endpoint', 'info');
        }
        
        async function showSystemStatus() {
            addOutput('RawrZ Security Platform Status:', 'header');
            try {
                const response = await fetch('/api/health');
                const result = await response.json();
                
                if (result.success) {
                    addOutput(`  Status: ${result.status}`, 'success');
                    addOutput(`  Engines: ${result.engines} Active`, 'success');
                    addOutput(`  Uptime: ${result.uptime.toFixed(2)}s`, 'info');
                    addOutput(`  Version: ${result.version}`, 'info');
                    addOutput(`  Service: ${result.service}`, 'info');
                } else {
                    addOutput('  Status: Error', 'error');
                }
            } catch (error) {
                addOutput('  Status: Offline', 'error');
                addOutput(`  Error: ${error.message}`, 'error');
            }
        }
        
        async function listAllEngines() {
            addOutput('Available Engines:', 'header');
            try {
                const response = await fetch('/api/engines');
                const result = await response.json();
                
                if (result.success) {
                    result.engines.forEach((engine, index) => {
                        const status = engine.status === 'active' ? '✅' : '❌';
                        addOutput(`  ${status} ${engine.name}`, 'info');
                    });
                    addOutput(`Total: ${result.total} engines`, 'info');
                } else {
                    addOutput('Error loading engines', 'error');
                }
            } catch (error) {
                addOutput(`Error: ${error.message}`, 'error');
            }
        }
        
        async function listFiles() {
            addOutput('Uploaded Files:', 'header');
            if (currentFiles.size === 0) {
                addOutput('  No files uploaded', 'info');
                return;
            }
            
            for (const [filename, fileData] of currentFiles) {
                addOutput(`  ${filename} (${fileData.size} bytes)`, 'info');
            }
        }
        
        async function handleFileUpload(args) {
            addOutput('Select file to upload...', 'info');
            fileInput.click();
            
            fileInput.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                addOutput(`Uploading ${file.name}...`, 'loading');
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        currentFiles.set(file.name, {
                            filename: result.filename,
                            size: result.size,
                            path: result.path
                        });
                        addOutput(`✅ File uploaded: ${file.name}`, 'success');
                        addOutput(`  Size: ${result.size} bytes`, 'info');
                        addOutput(`  Server filename: ${result.filename}`, 'info');
                    } else {
                        addOutput(`❌ Upload failed: ${result.error}`, 'error');
                    }
                } catch (error) {
                    addOutput(`❌ Upload error: ${error.message}`, 'error');
                }
            };
        }
        
        async function handleEncryption(args) {
            if (!args[0]) {
                addOutput('Usage: encrypt <filename> [extension]', 'error');
                addOutput('Example: encrypt document.pdf .encrypted', 'info');
                return;
            }
            
            const filename = args[0];
            const extension = args[1] || '.enc';
            
            if (!currentFiles.has(filename)) {
                addOutput(`File ${filename} not found. Use 'upload' command first.`, 'error');
                return;
            }
            
            const fileData = currentFiles.get(filename);
            addOutput(`Encrypting ${filename}...`, 'loading');
            
            try {
                // Create a new file input for the specific file
                const formData = new FormData();
                
                // We need to recreate the file from stored data
                const response = await fetch(`/api/download/${fileData.filename}`);
                const fileBlob = await response.blob();
                const file = new File([fileBlob], filename, { type: fileBlob.type });
                
                formData.append('file', file);
                formData.append('algorithm', 'AES-256-CBC');
                formData.append('extension', extension);
                
                const encryptResponse = await fetch('/api/encrypt-file', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await encryptResponse.json();
                
                if (result.success) {
                    addOutput('✅ File encrypted successfully!', 'success');
                    addOutput(`  Original: ${result.originalName} (${result.originalSize} bytes)`, 'info');
                    addOutput(`  Encrypted: ${result.encryptedName} (${result.encryptedSize} bytes)`, 'info');
                    addOutput(`  Algorithm: ${result.algorithm}`, 'info');
                    addOutput(`  Download: <span class="download-link" onclick="downloadFile('${result.downloadUrl}')">${result.downloadUrl}</span>`, 'info');
                    addOutput('  Encryption keys saved for decryption', 'warning');
                } else {
                    addOutput(`❌ Encryption failed: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`❌ Error: ${error.message}`, 'error');
            }
        }
        
        async function handleHashing(args) {
            if (!args[0]) {
                addOutput('Usage: hash <filename> [algorithm]', 'error');
                addOutput('Example: hash document.pdf sha256', 'info');
                return;
            }
            
            const filename = args[0];
            const algorithm = args[1] || 'sha256';
            
            if (!currentFiles.has(filename)) {
                addOutput(`File ${filename} not found. Use 'upload' command first.`, 'error');
                return;
            }
            
            const fileData = currentFiles.get(filename);
            addOutput(`Calculating ${algorithm.toUpperCase()} hash for ${filename}...`, 'loading');
            
            try {
                const formData = new FormData();
                
                // Recreate file from stored data
                const response = await fetch(`/api/download/${fileData.filename}`);
                const fileBlob = await response.blob();
                const file = new File([fileBlob], filename, { type: fileBlob.type });
                
                formData.append('file', file);
                formData.append('algorithm', algorithm);
                
                const hashResponse = await fetch('/api/hash-file', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await hashResponse.json();
                
                if (result.success) {
                    addOutput('✅ Hash calculated successfully!', 'success');
                    addOutput(`  File: ${result.filename}`, 'info');
                    addOutput(`  Algorithm: ${result.algorithm}`, 'info');
                    addOutput(`  Hash: ${result.hash}`, 'info');
                    addOutput(`  Size: ${result.size} bytes`, 'info');
                } else {
                    addOutput(`❌ Hash calculation failed: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`❌ Error: ${error.message}`, 'error');
            }
        }
        
        async function handleDownload(args) {
            if (!args[0]) {
                addOutput('Usage: download <filename>', 'error');
                return;
            }
            
            const filename = args[0];
            addOutput(`Downloading ${filename}...`, 'loading');
            
            try {
                const response = await fetch(`/api/download/${filename}`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    addOutput(`✅ File downloaded: ${filename}`, 'success');
                } else {
                    addOutput(`❌ Download failed: File not found`, 'error');
                }
            } catch (error) {
                addOutput(`❌ Download error: ${error.message}`, 'error');
            }
        }
        
        async function handleDecryption(args) {
            addOutput('Decryption functionality coming soon...', 'info');
        }
        
        async function handleScanning(args) {
            addOutput('File scanning functionality coming soon...', 'info');
        }
        
        async function handleCVECommands(args) {
            addOutput('CVE analysis functionality coming soon...', 'info');
        }
        
        async function handleGeneration(args) {
            addOutput('Payload generation functionality coming soon...', 'info');
        }
        
        async function handleBotCommands(args) {
            addOutput('Bot management functionality coming soon...', 'info');
        }
        
        async function handlePayloadCommands(args) {
            addOutput('Payload management functionality coming soon...', 'info');
        }
        
        async function handleStubCommands(args) {
            addOutput('Stub generation functionality coming soon...', 'info');
        }
        
        async function handleCertCommands(args) {
            addOutput('Certificate operations functionality coming soon...', 'info');
        }
        
        async function testAPIEndpoint(endpoint) {
            if (!endpoint) {
                addOutput('Usage: api <endpoint>', 'error');
                addOutput('Example: api /api/health', 'info');
                return;
            }
            
            addOutput(`Testing API endpoint: ${endpoint}`, 'loading');
            
            try {
                const response = await fetch(endpoint);
                const result = await response.json();
                
                addOutput(`✅ API Response:`, 'success');
                addOutput(JSON.stringify(result, null, 2), 'info');
            } catch (error) {
                addOutput(`❌ API Error: ${error.message}`, 'error');
            }
        }
        
        // Global function for download links
        window.downloadFile = async function(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const filename = url.split('/').pop();
                const downloadUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(downloadUrl);
                document.body.removeChild(a);
            } catch (error) {
                addOutput(`Download error: ${error.message}`, 'error');
            }
        };
    </script>
</body>
</html>